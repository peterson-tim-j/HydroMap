install.packages(c("sp", "gstat", "raster", "rgenoud", "RSAGA"))
library("gstat", lib.loc="C:/Program Files/R/R-4.0.3/library")
library("sp", lib.loc="C:/Program Files/R/R-4.0.3/library")
library("raster", lib.loc="C:/Program Files/R/R-4.0.3/library")
library("rgenoud", lib.loc="C:/Program Files/R/R-4.0.3/library")
library("parallel", lib.loc="C:/Program Files/R/R-4.0.3/library")
install.packages("devtools")
install.packages("rmarkdown")
install.packages("knitr")
install.packages("xfun")
install.packages("knitr")
install.packages("devtools")
install.packages("processx")
install.packages("htmltools")
install.packages("xfun")
install.packages("callr")
install.packages("bslib")
install.packages("bslib")
install.packages("htmltools")
install.packages(c("ape", "bit", "cachem", "class", "classInt", "cli", "cluster", "colorspace", "commonmark", "curl", "data.table", "DEoptim", "digest", "dplyr", "e1071", "fansi", "farver", "fastmap", "FNN", "foreign", "fs", "gert", "gstat", "haven", "htmltools", "httpuv", "intervals", "isoband", "jsonlite", "KernSmooth", "later", "lattice", "lwgeom", "maps", "maptools", "MASS", "Matrix", "mgcv", "nlme", "nnet", "openssl", "openxlsx", "plyr", "processx", "profvis", "proxy", "ps", "purrr", "ragg", "raster", "Rcpp", "readr", "readxl", "rgdal", "rlang", "roxygen2", "rpart", "s2", "sass", "sf", "sourcetools", "sp", "spatial", "stringi", "survival", "sys", "terra", "testthat", "tibble", "units", "utf8", "vctrs", "viridisLite", "vroom", "wk", "xfun", "xml2", "xts", "yaml", "zip", "zoo"))
install.packages("htmltools")
install.packages("devtools")
install.packages("callr")
install.packages("callr")
install.packages("callr")
install.packages("callr")
install.packages("devtools")
library(HydroMap)
set.env()
# Load water table observations from  April 2000 for Victoria, Australia and a 250m state-wide DEM.
data('victoria.groundwater')
# Load a model variogram and mapping parametyers found to be effective.
data('mapping.parameters')
# Define a simple kriging formula without MrVBF terms that does not require the package RSAGA.
f <- as.formula('head ~ elev + smoothing')
# Crop this Statewide DEM abd obs pointvs to a small in the centre.
# Note, this is done to reduce the runtime. Comment out these two lines to map the whole state.
DEM <- raster::crop(raster::raster(DEM), raster::extent(2400000, 2500000, 2550000, 2650000))
DEM = as(DEM,'SpatialGridDataFrame')
obs.data <- raster::crop(obs.data, DEM, inverse = F)
variogram.model = vgm(psill=10, model='Mat', range= 10000 , nugget=1, kappa=0.1);
o
obs.data$total_err_var = pmax(obs.data$total_err_var, 0.05)
library(HydroMap)
calib.results <- krige.head.calib(formula=f, grid=DEM, data=obs.data, newdata=0.25, nmin=0, nmax=Inf, maxdist=Inf, omax=0,
data.errvar.colname='total_err_var', model = variogram.model,  fit.variogram.type=1,
debug.level=1, use.cluster = T)
library(sp)
library(grid)
library(gstat)
library(raster)
library(RSAGA)
library(parallel)
library(rgenoud)
calib.results <- krige.head.calib(formula=f, grid=DEM, data=obs.data, newdata=0.25, nmin=0, nmax=Inf, maxdist=Inf, omax=0,
data.errvar.colname='total_err_var', model = variogram.model,  fit.variogram.type=1,
debug.level=1, use.cluster = T)
variogram.model = vgm(psill=10, model='Mat', range= 10000 , nugget=1, kappa=0.1);
obs.data$total_err_var = pmax(obs.data$total_err_var, 0.05)
calib.results <- krige.head.calib(formula=f, grid=DEM, data=obs.data, newdata=0.25, nmin=0, nmax=Inf, maxdist=Inf, omax=0,
data.errvar.colname='total_err_var', model = variogram.model,  fit.variogram.type=1,
debug.level=1, use.cluster = T)
library(HydroMap)
calib.results <- krige.head.calib(formula=f, grid=DEM, data=obs.data, newdata=0.25, nmin=0, nmax=Inf, maxdist=Inf, omax=0,
data.errvar.colname='total_err_var', model = variogram.model,  fit.variogram.type=1,
debug.level=1, use.cluster = T)
calib.results <- krige.head.calib(formula=f, grid=DEM, data=obs.data, newdata=0.25, nmin=0, nmax=Inf, maxdist=Inf, omax=0,
data.errvar.colname='total_err_var', model = variogram.model,  fit.variogram.type=1,
debug.level=1, use.cluster = T)
calib.results <- krige.head.calib(formula=f, grid=DEM, data=obs.data, newdata=0.25, nmin=0, nmax=Inf, maxdist=Inf, omax=0,
data.errvar.colname='total_err_var', model = variogram.model,  fit.variogram.type=1,
debug.level=1, use.cluster = T)
calib.results <- krige.head.calib(formula=f, grid=DEM, data=obs.data, newdata=0.25, nmin=0, nmax=Inf, maxdist=Inf, omax=0,
data.errvar.colname='total_err_var', model = variogram.model,  fit.variogram.type=1,
debug.level=1, use.cluster = T)
splitData[[1]]
nrow(splitData[[1]])
splitData[[1]]$elev
est <- do.call("rbind", parLapplyLB(cl, splitData, function(lst)
krige.head.crossval(
newdata=lst,
formula=formula,
model=model,
model.landtype=model.landtype,
model.landtype.head=model.landtype.head,
model.fixedHead=model.fixedHead,
model.fixedHead.head=model.fixedHead.head,
nmin=nmin,
nmax=nmax,
nmax.fixedHead=nmax.fixedHead,
nmin.fixedHead=nmin.fixedHead,
omax.fixedHead=omax.fixedHead,
maxdist=maxdist,
omax=omax,
do.depth.est=do.depth.est,
use.MrVBF=use.MrVBF,
use.MrRTF=use.MrRTF,
use.DEMsmoothing=use.DEMsmoothing,
use.LandCatagory=use.LandCatagory,
use.FixedHeads=use.FixedHeads,
data=data,
data.fixedHead=data.fixedHead,
data.weights=data.weights,
smooth.std=smooth.std,
grid.elev=grid.elev,
grid.MrVBF=grid.MrVBF,
grid.MrRTF=grid.MrRTF,
grid.LandType=grid.LandType,
grid.params=grid.params,
debug.level=debug.level)
))
nclus
ceil(2.2)
ceiling(2.2)
library(HydroMap)
calib.results <- krige.head.calib(formula=f, grid=DEM, data=obs.data, newdata=0.25, nmin=0, nmax=Inf, maxdist=Inf, omax=0,
data.errvar.colname='total_err_var', model = variogram.model,  fit.variogram.type=1,
debug.level=1, use.cluster = T)
est
library(HydroMap)
calib.results <- krige.head.calib(formula=f, grid=DEM, data=obs.data, newdata=0.25, nmin=0, nmax=Inf, maxdist=Inf, omax=0,
data.errvar.colname='total_err_var', model = variogram.model,  fit.variogram.type=1,
debug.level=0, use.cluster = T)
splitData[[i]])
splitData[[i]]
nrow(splitData[[i]])
j=1
j++
library(HydroMap)
library(HydroMap)
calib.results <- krige.head.calib(formula=f, grid=DEM, data=obs.data, newdata=0.25, nmin=0, nmax=Inf, maxdist=Inf, omax=0,
data.errvar.colname='total_err_var', model = variogram.model,  fit.variogram.type=1,
debug.level=0, use.cluster = T)
splitData[[i]]
calib.results <- krige.head.calib(formula=f, grid=DEM, data=obs.data, newdata=0.25, nmin=0, nmax=Inf, maxdist=Inf, omax=0,
data.errvar.colname='total_err_var', model = variogram.model,  fit.variogram.type=1,
debug.level=0, use.cluster = T)
ind.isempty
calib.results <- krige.head.calib(formula=f, grid=DEM, data=obs.data, newdata=0.25, nmin=0, nmax=Inf, maxdist=Inf, omax=0,
data.errvar.colname='total_err_var', model = variogram.model,  fit.variogram.type=1,
debug.level=0, use.cluster = 10)
calib.results <- krige.head.calib(formula=f, grid=DEM, data=obs.data, newdata=0.25, nmin=0, nmax=Inf, maxdist=Inf, omax=0,
data.errvar.colname='total_err_var', model = variogram.model,  fit.variogram.type=1,
debug.level=0, use.cluster = F)
calib.results <- krige.head.calib(formula=f, grid=DEM, data=obs.data, newdata=0.25, nmin=0, nmax=Inf, maxdist=Inf, omax=0,
data.errvar.colname='total_err_var', model = variogram.model,  fit.variogram.type=1,
debug.level=0, use.cluster = 2)
library(HydroMap)
calib.results <- krige.head.calib(formula=f, grid=DEM, data=obs.data, newdata=0.25, nmin=0, nmax=Inf, maxdist=Inf, omax=0,
data.errvar.colname='total_err_var', model = variogram.model,  fit.variogram.type=1,
debug.level=0, use.cluster = 2)
calib.results <- krige.head.calib(formula=f, grid=DEM, data=obs.data, newdata=0.25, nmin=0, nmax=Inf, maxdist=Inf, omax=0,
data.errvar.colname='total_err_var', model = variogram.model,  fit.variogram.type=1,
debug.level=0, use.cluster = 2)
calib.results <- krige.head.calib(formula=f, grid=DEM, data=obs.data, newdata=0.25, nmin=0, nmax=Inf, maxdist=Inf, omax=0,
data.errvar.colname='total_err_var', model = variogram.model,  fit.variogram.type=1,
debug.level=0, use.cluster = 2)
calib.results <- krige.head.calib(formula=f, grid=DEM, data=obs.data, newdata=0.25, nmin=0, nmax=Inf, maxdist=Inf, omax=0,
data.errvar.colname='total_err_var', model = variogram.model,  fit.variogram.type=1,
debug.level=0, use.cluster = 2,pop.size.multiplier=5)
calib.results <- krige.head.calib(formula=f, grid=DEM, data=obs.data, newdata=0.25, nmin=0, nmax=Inf, maxdist=Inf, omax=0,
data.errvar.colname='total_err_var', model = variogram.model,  fit.variogram.type=1,
debug.level=0, use.cluster = 2,pop.size.multiplier=5)
calib.results <- krige.head.calib(formula=f, grid=DEM, data=obs.data, newdata=0.25, nmin=0, nmax=Inf, maxdist=Inf, omax=0,
data.errvar.colname='total_err_var', model = variogram.model,  fit.variogram.type=1,
debug.level=0, use.cluster = 2,pop.size.multiplier=5)
calib.results$lookup.table
calib.results$param.Names
calib.results$param.Names
library(HydroMap)
library(HydroMap)
library(HydroMap)
devtools::document()
library(HydroMap)
library(HydroMap)
library(RSAGA)
# Setup RSAGA with the paths to the requuired modules. Note you will to do this yourself for your own
# installation of SAGA.
set.env(saga.path = 'C:/Program Files (x86)/saga-9.0.1_x64',saga.modules = 'C:/Program Files (x86)/saga-9.0.1_x64/tools')
# Load water table observations from  April 2000 for Victoria, Australia and a 250m state-wide DEM.
data('victoria.groundwater')
# Crop this stat-ewide DEM and data  points to a small in the centre north.
DEM <- raster::crop(raster::raster(DEM), raster::extent(2400000, 2500000, 2550000, 2650000))
DEM = as(DEM,'SpatialGridDataFrame')
obs.data <- raster::crop(obs.data, DEM, inverse = F)
# Load a model variogram and mapping parametyers found to be effective.
data('mapping.parameters')
floor(0.25*nrow(obs.data))
nObs.prediction = floor(0.25*nrow(obs.data))
predictionData = sample(obs.data, nObs.prediction, replace=F)
predictionData.index = sample(1:nObs.prediction, nObs.prediction, replace=F)
nObs.prediction = floor(0.25*nrow(obs.data))
predictionData.index = sample(1:nObs.prediction, nObs.prediction, replace=F)
predictionData = obs.Data[predictionData.index,]
predictionData = obs.data[predictionData.index,]
trainingData = obs.data[-predictionData.index,]
spplot(predictionData,2)
sp::spplot(predictionData,2)
obs.data$DTWT = obs.data$elev - obs.data$head
data('mapping.parameters')
obs.data$DTWT = obs.data$elev - obs.data$head
nObs.prediction = floor(0.25*nrow(obs.data))
predictionData.index = sample(1:nObs.prediction, nObs.prediction, replace=F)
predictionData = obs.data[predictionData.index,]
trainingData = obs.data[-predictionData.index,]
# Load a model variogram and mapping parametyers found to be effective.
data('mapping.parameters')
# Caculate the depth to water table
obs.data$DTWT = obs.data$elev - obs.data$head
# Enforce a minimum error variance of 5cm ^2 for the groundwater head elevation.
obs.data$total_err_var = pmax(obs.data$total_err_var, 0.05^2)
# Define the prediction data by randomly sample 25% of the observed data points.
# The remaining 75% of data points are used for the presictions.
nObs.prediction = floor(0.25*nrow(obs.data))
predictionData.index = sample(1:nObs.prediction, nObs.prediction, replace=F)
predictionData = obs.data[predictionData.index,]
trainingData = obs.data[-predictionData.index,]
# Plot the depth to water table of the prediction and training data
sp::spplot(predictionData, 'DTWT',scales = list(draw = TRUE)), main='Prediction data DTWT [m]')
sp::spplot(trainingData, 'DTWT',scales = list(draw = TRUE)), main='Training data DTWT [m]')
sp::spplot(predictionData, 'DTWT',scales = list(draw = TRUE), main='Prediction data DTWT [m]')
sp::spplot(trainingData, 'DTWT',scales = list(draw = TRUE), main='Training data DTWT [m]')
nObs.prediction
nObs = nrow(obs.data);
nObs.prediction = floor(0.25*nObs)
predictionData.index = sample(1:nObs, nObs.prediction, replace=F)
predictionData = obs.data[predictionData.index,]
trainingData = obs.data[-predictionData.index,]
# Plot the depth to water table of the prediction and training data
sp::spplot(predictionData, 'DTWT',scales = list(draw = TRUE), main='Prediction data DTWT [m]')
sp::spplot(trainingData, 'DTWT',scales = list(draw = TRUE), main='Training data DTWT [m]')
?cut
est=cut(obs.data,breks=c(-10,0,2,5,10,25,50))
est=cut(obs.data$DTWT,breks=c(-10,0,2,5,10,25,50))
est=cut(obs.data$DTWT,breaks=c(-10,0,2,5,10,25,50))
est
est=cut(obs.data$DTWT,breaks=c(-Inf,0,2,5,10,25,50), labels=c('<0m','0-2m','2-5m','5-10m','10-25m','25-50m','>50m'),include.lowest=T)
est=cut(obs.data$DTWT,breaks=c(-Inf,0,2,5,10,25,50,Inf), labels=c('<0m','0-2m','2-5m','5-10m','10-25m','25-50m','>50m'),include.lowest=T)
est
obs.data$DTWT.catagories =cut(obs.data$DTWT,breaks=c(-Inf,0,2,5,10,25,50), labels=c('<0m','0-2m','2-5m','5-10m','10-25m','25-50m','>50m'),include.lowest=T)
obs.data$DTWT.catagories =cut(obs.data$DTWT,breaks=c(-Inf,0,2,5,10,25,50, infert), labels=c('<0m','0-2m','2-5m','5-10m','10-25m','25-50m','>50m'),include.lowest=T)
obs.data$DTWT.catagories = cut(obs.data$DTWT,breaks=c(-Inf,0,2,5,10,25,50, infert), labels=F,include.lowest=T)
obs.data$DTWT.catagories = as.double( cut(obs.data$DTWT,breaks=c(-Inf,0,2,5,10,25,50, infert), labels=F,include.lowest=T))
obs.data$DTWT.catagories =cut(obs.data$DTWT,breaks=c(-Inf,0,2,5,10,25,50, Inf ), labels=c('<0m','0-2m','2-5m','5-10m','10-25m','25-50m','>50m'),include.lowest=T)
# Load a model variogram and mapping parametyers found to be effective.
data('mapping.parameters')
# Calculate the depth to water table (DTWT)
obs.data$DTWT = obs.data$elev - obs.data$head
# Convert DTWT to catagories, to aid mapping
obs.data$DTWT.cats =cut(obs.data$DTWT,breaks=c(-Inf,0,2,5,10,25,50, Inf ),
labels=c('<0m','0-2m','2-5m','5-10m','10-25m','25-50m','>50m'),include.lowest=T)
# Enforce a minimum error variance of 5cm ^2 for the groundwater head elevation.
obs.data$total_err_var = pmax(obs.data$total_err_var, 0.05^2)
# Define the prediction data by randomly sample 25% of the observed data points.
# The remaining 75% of data points are used for the presictions.
nObs = nrow(obs.data);
nObs.prediction = floor(0.25*nObs)
predictionData.index = sample(1:nObs, nObs.prediction, replace=F)
predictionData = obs.data[predictionData.index,]
trainingData = obs.data[-predictionData.index,]
# Plot the depth to water table of the prediction and training data
sp::spplot(predictionData, 'DTWT.cats',scales = list(draw = TRUE), main='Prediction data DTWT [m]')
sp::spplot(trainingData, 'DTWT.cats',scales = list(draw = TRUE), main='Training data DTWT [m]')
# Define the covariates for the kriging.
f <- as.formula('head ~ elev + smoothing')
# Define the base variogram model. Note, only the structure is used - not
# the valuaes.
variogram.model = gstat::vgm(psill=10, model='Mat', range= 10000 , nugget=1, kappa=0.1);
# Calibrate the mapping parameters with 25% of the data randomly selected and using 2 cores.
# NOTE 1: The rigor of the calibration is best controlled using the pop.size.multiplier input.
# Here the size of the population of random guesses equals four time the number of calibration
# parameters.
# NOTE 2: The 25% of random data are used to calculate the prediction error - which is minimised.
# The remaining 74% of data is used to make the predicts.
# NOTE 3: Here the smoothing parameter can between 0.5 and 1.5.
calib.results <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
variogram.model,  fit.variogram.type=1, smooth.std = c(0.5, 1.5),
pop.size.multiplier=4, debug.level=0, use.cluster = 2)
# Do the interpolation of the point data using the calibration results.
# NOTE: All of the observed data is used for the calibration. All CPU cores are also used.
head.grid <- krige.head(calibration.results = calib.results, data=obs.data, use.cluster = T)
# Map the head elevation and kriging uncertainty.
sp::spplot(head.grid, scales = list(draw = TRUE))
# Calculate the depth to water table.
# NOTE, this requires getting the DEM elevation into the head grids - event if there are a
# different number of finite values.
sp::gridded(head.grid)=F
sp::gridded(DEM)=F
head.grid$DBNS = DEM$DEM - head.grid$head
sp::gridded(head.grid)=T
# Map the depth to water table.
sp::spplot(head.grid,3, scales = list(draw = TRUE))
library(HydroMap)
calib.results <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
variogram.model,  fit.variogram.type=1, smooth.std = c(0.5, 1.5),
pop.size.multiplier=4, debug.level=0, use.cluster = F)
library(RSAGA)
# Setup RSAGA with the paths to the requuired modules. Note you will to do this yourself for your own
# installation of SAGA.
set.env(saga.path = 'C:/Program Files (x86)/saga-9.0.1_x64',saga.modules = 'C:/Program Files (x86)/saga-9.0.1_x64/tools')
# Load water table observations from  April 2000 for Victoria, Australia and a 250m state-wide DEM.
data('victoria.groundwater')
# Crop this stat-ewide DEM and data  points to a small in the centre north.
DEM <- raster::crop(raster::raster(DEM), raster::extent(2400000, 2500000, 2550000, 2650000))
DEM = as(DEM,'SpatialGridDataFrame')
obs.data <- raster::crop(obs.data, DEM, inverse = F)
# Load a model variogram and mapping parametyers found to be effective.
data('mapping.parameters')
# Calculate the depth to water table (DTWT)
obs.data$DTWT = obs.data$elev - obs.data$head
# Convert DTWT to catagories, to aid mapping
obs.data$DTWT.cats =cut(obs.data$DTWT,breaks=c(-Inf,0,2,5,10,25,50, Inf ),
labels=c('<0m','0-2m','2-5m','5-10m','10-25m','25-50m','>50m'),include.lowest=T)
# Enforce a minimum error variance of 5cm ^2 for the groundwater head elevation.
obs.data$total_err_var = pmax(obs.data$total_err_var, 0.05^2)
# Define the prediction data by randomly sample 25% of the observed data points.
# The remaining 75% of data points are used for the presictions.
nObs = nrow(obs.data);
nObs.prediction = floor(0.25*nObs)
predictionData.index = sample(1:nObs, nObs.prediction, replace=F)
predictionData = obs.data[predictionData.index,]
trainingData = obs.data[-predictionData.index,]
# Plot the depth to water table of the prediction and training data
sp::spplot(predictionData, 'DTWT.cats',scales = list(draw = TRUE), main='Prediction data DTWT [m]')
sp::spplot(trainingData, 'DTWT.cats',scales = list(draw = TRUE), main='Training data DTWT [m]')
# Define the covariates for the kriging.
f <- as.formula('head ~ elev + smoothing')
# Define the base variogram model. Note, only the structure is used - not
# the valuaes.
variogram.model = gstat::vgm(psill=10, model='Mat', range= 10000 , nugget=1, kappa=0.1);
calib.results <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
variogram.model,  fit.variogram.type=1, smooth.std = c(0.5, 1.5),
pop.size.multiplier=4, debug.level=0, use.cluster = F)
smooth.std
paste('smoothedDEM_std',smooth.std,sep='')
calib.results <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
variogram.model,  fit.variogram.type=1, smooth.std = c(0.5, 1.5),
pop.size.multiplier=4, debug.level=0, use.cluster = F)
calib.results <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
variogram.model,  fit.variogram.type=1, smooth.std = c(0.5, 1.5),
pop.size.multiplier=4, debug.level=0, use.cluster = F)
smooth.std
smooth.std
library(HydroMap)
calib.results <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
variogram.model,  fit.variogram.type=1, smooth.std = c(0.5, 1.5),
pop.size.multiplier=4, debug.level=0, use.cluster = F)
force(smooth.std)
smooth.std
newdata
