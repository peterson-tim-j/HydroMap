raster::contour(raster::raster(head.grid.example3,1), levels = seq(70,125,by=5), add=T)
dev.off()
# Calculate the depth to water table.
sp::gridded(head.grid.example3)=F
sp::gridded(DEM)=F
head.grid.example3$DTWT = DEM$DEM - head.grid.example3$head
sp::gridded(head.grid.example3)=T
sp::gridded(DEM)=T
sp::fullgrid(DEM)=T
# Categorise the DTWT to seven classes.
head.grid.example3$DTWT.cats =cut(head.grid.example3$DTWT,breaks=c(-Inf,0,2,5,10,25,50, Inf ),
labels=c('<0m','0-2m','2-5m','5-10m','10-25m','25-50m','>50m'),include.lowest=T)
# Map the categorised depth to water table.
png('Example3_DTWT.png')
sp::spplot(head.grid.example3,'DTWT.cats', scales = list(draw = TRUE))
dev.off()
library(HydroMap)
calib.results.example3 <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
variogram.model,  fit.variogram.type=1, smooth.std = c(0.5, 2.5),
pop.size.multiplier=4, debug.level=0, use.cluster = 2)
variogram.model = gstat::vgm(psill=25, model='Mat', range= 20000 , nugget=5, kappa=0.1);
calib.results.example3 <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
variogram.model,  fit.variogram.type=1, smooth.std = c(0.5, 2.5),
pop.size.multiplier=4, debug.level=0, use.cluster = 2)
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 2.5),
pop.size.multiplier=4, debug.level=0, use.cluster = 2)
model[1]
model[2]
model
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 2.5),
pop.size.multiplier=4, debug.level=0, use.cluster = 2)
model.types
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 2.5),
pop.size.multiplier=4, debug.level=0, use.cluster = 2)
library(HydroMap)
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 2.5),
pop.size.multiplier=4, debug.level=0, use.cluster = 2)
model.types
class(model.types)
library(HydroMap)
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 2.5),
pop.size.multiplier=4, debug.level=0, use.cluster = 2)
library(HydroMap)
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 2.5),
pop.size.multiplier=4, debug.level=0, use.cluster = 2)
model.types
??upper
library(HydroMap)
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 2.5),
pop.size.multiplier=4, debug.level=0, use.cluster = 2)
library(HydroMap)
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 2.5),
pop.size.multiplier=4, debug.level=0, use.cluster = 2)
stringr::str_to_title(model)
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 2.5),
pop.size.multiplier=4, debug.level=0, use.cluster = 2)
model
model.types
model.types[2]
model.types[2,1]
model.types[2,2]
model[i] %in% model.types[,1]
library(HydroMap)
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 2.5),
pop.size.multiplier=4, debug.level=0, use.cluster = 2)
model[i] %in% model.types[,1]
!(model[i] %in% model.types[,1])
do.head.est
do.depth.est
resid
model
max.Its
library(HydroMap)
pop.size.multiplier=4, debug.level=0, use.cluster = 2)
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 2.5),
pop.size.multiplier=4, debug.level=0, use.cluster = 2)
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 2.5),
pop.size.multiplier=4, debug.level=0, use.cluster = 2)
library(HydroMap)
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 2.5),
pop.size.multiplier=4, debug.level=0, use.cluster = 2)
seq(0.25, 2.5, by = 0.1)
seq(0.2, 2.5, by = 0.1)
library(HydroMap)
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 2.5),
pop.size.multiplier=4, debug.level=0, use.cluster = 2)
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 3.5),
pop.size.multiplier=4, debug.level=0, use.cluster = 2)
smoothingKernal = matrix(1,5,5);
for (i in 1:5) {
for(j in 1:5) {
smoothingKernal[i,j] = (i-3)^2 + (j-3)^2
}
}
ind_smooth=1
smooth.std[ind_smooth]-3.49650313683237
sigmaWeights = 1/(2*pi*smooth.std[ind_smooth]^2) * exp(-smoothingKernal/(2*smooth.std[ind_smooth]^2) )
sigmaWeights/sum(sigmaWeights)
smooth.std[ind_smooth]=3.49650313683237
sigmaWeights = 1/(2*pi*smooth.std[ind_smooth]^2) * exp(-smoothingKernal/(2*smooth.std[ind_smooth]^2) )
smooth.std[ind_smooth]=3.49650313683237
sigmaWeights = 1/(2*pi*smooth.std[ind_smooth]^2) * exp(-smoothingKernal/(2*smooth.std[ind_smooth]^2) )
sigmaWeights/sum(sigmaWeights)
smooth.std[ind_smooth]=5
sigmaWeights = 1/(2*pi*smooth.std[ind_smooth]^2) * exp(-smoothingKernal/(2*smooth.std[ind_smooth]^2) )
sigmaWeights/sum(sigmaWeights)
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 5),
pop.size.multiplier=4, debug.level=0, use.cluster = F)
smooth.std
length(smooth.std)
max(1,round(length(smooth.std)/2))
smooth.std
smooth.std
smooth.std
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 5),
pop.size.multiplier=4, debug.level=0, use.cluster = F)
ind_smooth
min(smooth.std) + range(smooth.std)/2
smooth.std
pmin(smooth.std)
range(smooth.std)
min(c(1,2,3))
range(c(1,2,3))
?range
?min
min(c(1,2,3))
pmin(c(1,2,3))
min(c(1,2,3))
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 5),
pop.size.multiplier=4, debug.level=0, use.cluster = F)
library(HydroMap)
library(HydroMap)
min(c(1,2,3))
nase::min(c(1,2,3))
base::min(c(1,2,3))
base::range(c(1,2,3))
library(HydroMap)
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 5),
pop.size.multiplier=4, debug.level=0, use.cluster = F)
min(smooth.std) + (max(smooth.std)-min(smooth.std))/2
smooth.std
library(HydroMap)
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 5),
pop.size.multiplier=4, debug.level=0, use.cluster = F)
smooth.std.tmp
mrvbf.ppctl.tmp
model
kernal.ncells=5
ceil(kernal.ncells/2)
ceiling(kernal.ncells/2)
kernal.ncells=7
kernal.ncells.centre = ceiling(kernal.ncells/2)
kernal.ncells.centre
smoothingKernal = matrix(1,kernal.ncells,kernal.ncells);
for (i in 1:kernal.ncells) {
for(j in 1:kernal.ncells) {
smoothingKernal[i,j] = (i-kernal.ncells.centre)^2 + (j-kernal.ncells.centre)^2
}
}
smoothingKernal
ind_smooth
smooth.std
sigmaWeights = 1/(2*pi*smooth.std[ind_smooth]^2) * exp(-smoothingKernal/(2*smooth.std[ind_smooth]^2) )
sigmaWeights/sum(sigmaWeights)
library(HydroMap)
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 5),
pop.size.multiplier=4, debug.level=0, use.cluster = F)
library(HydroMap)
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 5),
pop.size.multiplier=4, debug.level=0, use.cluster = F)
library(HydroMap)
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 5),
pop.size.multiplier=4, debug.level=0, use.cluster = F)
grid.DEM.params
grid.MrVBF.params
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 5),
pop.size.multiplier=4, debug.level=0, use.cluster = F)
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 5),
pop.size.multiplier=4, debug.level=0, use.cluster = F)
y.rowbuffer
x.colbuffer
extent(grid.asRaster)
raster::extent(grid.asRaster)
raster::dim(grid.asRaster)
raster::dim(grid.asRaster)
grid.asRaster
grid.asRaster
grid.DEM.params
grid.MrVBF.params
library(HydroMap)
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 5),
pop.size.multiplier=4, debug.level=0, use.cluster = F)
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 5),
pop.size.multiplier=4, debug.level=0, use.cluster = F)
grid.asRaster
grid
names(grid)
library(HydroMap)
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 5),
pop.size.multiplier=4, debug.level=0, use.cluster = F)
names(grid)
names(grid)
names(grid)
grid.DEM.params
grid.MrVBF.params
set.env()
set.env(saga.path = 'C:/Program Files (x86)/saga-9.0.1_x64',saga.modules = 'C:/Program Files (x86)/saga-9.0.1_x64/tools')
calib.results.example3b <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
'mat',  fit.variogram.type=1, smooth.std = c(0.5, 5),
pop.size.multiplier=4, debug.level=0, use.cluster = F)
grid.MrVBF.params
grid.DEM.params
library(HydroMap)
library(RSAGA)
# Setup RSAGA with the paths to the requuired modules. Note you will to do this yourself for your own
# installation of SAGA.
set.env(saga.path = 'C:/Program Files (x86)/saga-9.0.1_x64',saga.modules = 'C:/Program Files (x86)/saga-9.0.1_x64/tools')
# Load water table observations from  April 2000 for Victoria, Australia and a 250m state-wide DEM.
data('victoria.groundwater')
# Crop this stat-ewide DEM and data  points to a small in the centre north.
DEM <- raster::crop(raster::raster(DEM), raster::extent(2400000, 2500000, 2550000, 2650000))
DEM = as(DEM,'SpatialGridDataFrame')
obs.data <- raster::crop(obs.data, DEM, inverse = F)
# Load a model variogram and mapping parametyers found to be effective.
data('mapping.parameters')
# Calculate the depth to water table (DTWT)
obs.data$DTWT = obs.data$elev - obs.data$head
# Convert DTWT to catagories, to aid mapping
obs.data$DTWT.cats =cut(obs.data$DTWT,breaks=c(-Inf,0,2,5,10,25,50, Inf ),
labels=c('<0m','0-2m','2-5m','5-10m','10-25m','25-50m','>50m'),include.lowest=T)
# Enforce a minimum error variance of 5cm ^2 for the groundwater head elevation.
obs.data$total_err_var = pmax(obs.data$total_err_var, 0.05^2)
# Define the prediction data by randomly sample 25% of the observed data points.
# The remaining 75% of data points are used for the presictions.
nObs = nrow(obs.data);
nObs.prediction = floor(0.25*nObs)
set.seed(123456, sample.kind='default')
predictionData.index = sample(1:nObs, nObs.prediction, replace=F)
predictionData = obs.data[predictionData.index,]
trainingData = obs.data[-predictionData.index,]
# Plot the depth to water table of the prediction and training data
png('Example1_pointData_A.png')
sp::spplot(predictionData, 'DTWT.cats',scales = list(draw = TRUE), main='Prediction data DTWT [m]')
dev.off()
png('Example1_pointData_B.png')
sp::spplot(trainingData, 'DTWT.cats',scales = list(draw = TRUE), main='Training data DTWT [m]')
dev.off()
f <- as.formula('head ~ elev + smoothing + log(MrVBF) + log(MrRTF)')
variogram.model = 'Mat';
# Calibrate the mapping parameters with 25% of the data randomly selected and using 2 cores.
calib.results.example3 <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
variogram.model,  fit.variogram.type=1, smooth.std = c(0.5, 2.5),
pop.size.multiplier=4, debug.level=0, use.cluster = F)
sigmaWeights
# Calibrate the mapping parameters with 25% of the data randomly selected and using 2 cores.
calib.results.example3 <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
variogram.model,  fit.variogram.type=1, smooth.std = c(0.5, 2.5),
pop.size.multiplier=4, debug.level=0, use.cluster = F)
sigmaWeights
dem.asRaster
library(HydroMap)
# Calibrate the mapping parameters with 25% of the data randomly selected and using 2 cores.
calib.results.example3 <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
variogram.model,  fit.variogram.type=1, smooth.std = c(0.5, 2.5),
pop.size.multiplier=4, debug.level=0, use.cluster = F)
# Calibrate the mapping parameters with 25% of the data randomly selected and using 2 cores.
calib.results.example3 <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
variogram.model,  fit.variogram.type=1, smooth.std = c(0.5, 2.5),
pop.size.multiplier=4, debug.level=0, use.cluster = 2)
DEM.tmp = DEM
DEM.tmp = ratser::extend(DEM.tmp,c(7,7),NA)
DEM.tmp = raster::extend(DEM.tmp,c(7,7),NA)
DEM.tmp = raster::raster(DEM.tmp)
DEM.tmp = raster::extend(DEM.tmp,c(7,7),NA)
plot(DEM,tmp)
plot(DEM.tmp)
plot(DEM.tmp,1)
class(DEM.tmp)
plot(DEM.tmp$DEM)
spplot(DEM.tmp)
raster::plot(DEM.tmp$DEM)
extent(DEM.tmp)
raster::extent(DEM.tmp)
DEM.tmp2 = raster::extend(DEM.tmp,c(-7,-7),NA)
extent(DEM.tmp2)
raster::extent(DEM.tmp2)
raster::extent(raster::ratser(DEM))
raster::extent(raster::raster(DEM))
DEM.tmp2 = raster::extend(DEM.tmp,c(-5,-5),NA)
raster::extent(DEM.tmp2)
raster::extent(DEM.tmp)
1750/250
raster::extent(DEM.tmp2)
DEM.tmp2 = raster::crop(DEM.tmp,raster::extent(raster::raster(DEM)))
raster::extent(DEM.tmp2)
raster::extent(raster::raster(DEM))
raster::plot(raster::raster(DEM)-DEM.tmp2)
max(abs(raster::plot(raster::raster(DEM)-DEM.tmp2)))
err= raster::raster(DEM)-DEM.tmp2
err
library(HydroMap)
# Calibrate the mapping parameters with 25% of the data randomly selected and using 2 cores.
calib.results.example3 <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
variogram.model,  fit.variogram.type=1, smooth.std = c(0.5, 2.5),
pop.size.multiplier=2, debug.level=0, use.cluster = F)
head.grid.example1 <- krige.head(calibration.results = calib.results.example1, data=obs.data, use.cluster = T)
head.grid.example3 <- krige.head(calibration.results = calib.results.example3, data=obs.data, use.cluster = T)
library(HydroMap)
head.grid.example3 <- krige.head(calibration.results = calib.results.example3, data=obs.data, use.cluster = T)
extend.DEM
grid.asRaster
head.asRaster
grid
grid.asRaster
raster::raster(grid$elev)
library(HydroMap)
# Calibrate the mapping parameters with 25% of the data randomly selected and using 2 cores.
calib.results.example3 <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
variogram.model,  fit.variogram.type=1, smooth.std = c(0.5, 2.5),
pop.size.multiplier=2, debug.level=0, use.cluster = F)
library(HydroMap)
setwd("C:/Users/tpet0008/Documents/junk")
library(RSAGA)
# Setup RSAGA with the paths to the requuired modules. Note you will to do this yourself for your own
# installation of SAGA.
set.env(saga.path = 'C:/Program Files (x86)/saga-9.0.1_x64',saga.modules = 'C:/Program Files (x86)/saga-9.0.1_x64/tools')
# Load water table observations from  April 2000 for Victoria, Australia and a 250m state-wide DEM.
data('victoria.groundwater')
# Crop this stat-ewide DEM and data  points to a small in the centre north.
DEM <- raster::crop(raster::raster(DEM), raster::extent(2400000, 2500000, 2550000, 2650000))
DEM = as(DEM,'SpatialGridDataFrame')
obs.data <- raster::crop(obs.data, DEM, inverse = F)
# Load a model variogram and mapping parametyers found to be effective.
data('mapping.parameters')
# Calculate the depth to water table (DTWT)
obs.data$DTWT = obs.data$elev - obs.data$head
# Convert DTWT to catagories, to aid mapping
obs.data$DTWT.cats =cut(obs.data$DTWT,breaks=c(-Inf,0,2,5,10,25,50, Inf ),
labels=c('<0m','0-2m','2-5m','5-10m','10-25m','25-50m','>50m'),include.lowest=T)
# Enforce a minimum error variance of 5cm ^2 for the groundwater head elevation.
obs.data$total_err_var = pmax(obs.data$total_err_var, 0.05^2)
# Define the prediction data by randomly sample 25% of the observed data points.
# The remaining 75% of data points are used for the presictions.
nObs = nrow(obs.data);
nObs.prediction = floor(0.25*nObs)
set.seed(123456, sample.kind='default')
predictionData.index = sample(1:nObs, nObs.prediction, replace=F)
predictionData = obs.data[predictionData.index,]
trainingData = obs.data[-predictionData.index,]
# Plot the depth to water table of the prediction and training data
png('Example1_pointData_A.png')
sp::spplot(predictionData, 'DTWT.cats',scales = list(draw = TRUE), main='Prediction data DTWT [m]')
dev.off()
png('Example1_pointData_B.png')
sp::spplot(trainingData, 'DTWT.cats',scales = list(draw = TRUE), main='Training data DTWT [m]')
dev.off()
# Define the variogram model. This can be either a full variogram object (see `gstat:vgm`),
# which is then calibrated, or simply a type of variogram, as used here. When the type is input then
# the initial variogram parameters are estimated using the residuals of the observed head and the
# covariates, using ordinary least squares. Latter calibration of these parameters uses a range of 0.1
# and 10 times the initial estimates.
variogram.model = 'Mat';
# Define the covariates for the kriging.
f <- as.formula('head ~ elev + smoothing + log(MrVBF) + log(MrRTF)')
calib.results.example3 <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
variogram.model,  fit.variogram.type=1, smooth.std = c(0.5, 2.5),
pop.size.multiplier=4, debug.level=0, use.cluster = F)
library(HydroMap)
calib.results.example3 <- krige.head.calib(formula=f, grid=DEM, data=trainingData, newdata=predictionData,
nmin=0, nmax=Inf, maxdist=Inf, omax=0, data.errvar.colname='total_err_var', model =
variogram.model,  fit.variogram.type=1, smooth.std = c(0.5, 2.5),
pop.size.multiplier=4, debug.level=0, use.cluster = F)
head.grid.example3 <- krige.head(calibration.results = calib.results.example3, data=obs.data, use.cluster = T)
pkg.env$DEM.data
library(HydroMap)
clear.env()
library(HydroMap)
clear.env()
library(HydroMap)
clear.env()
library(HydroMap)
devtools::document()
library(HydroMap)
path <- find.package("HydroMap")
devtools::document()
devtools::document()
setwd("C:/Users/tpet0008/Documents/HydroMap")
devtools::document()
library(HydroMap)
clear.env()
head.grid.example3 <- krige.head(calibration.results = calib.results.example3, data=obs.data, use.cluster = T)
calib.results.example3$inputs$grid
class(calib.results.example3$inputs$grid)
extent(calib.results.example3$inputs$grid)
head.grid.example3 <- krige.head(calibration.results = calib.results.example3, data=obs.data, use.cluster = T)
head.grid.example3 <- krige.head(calibration.results = calib.results.example3, data=obs.data, use.cluster = T)
grid.asRaster
raster::plot(grid.asRaster)
raster::plot(grid.asRaster)
grid.asRaster
raster::plot(grid.asRaster)
colnames
grid
names(grid)
library(HydroMap)
head.grid.example3 <- krige.head(calibration.results = calib.results.example3, data=obs.data, use.cluster = T)
grid.asRaster = raster::raster(grid)
head.asRaster = raster::raster(head)
library(HydroMap)
head.grid.example3 <- krige.head(calibration.results = calib.results.example3, data=obs.data, use.cluster = T)
head.asRaster$DTWT = grid.asRaster[[1]] - head.asRaster$head
library(HydroMap)
head.grid.example3 <- krige.head(calibration.results = calib.results.example3, data=obs.data, use.cluster = T)
grid.asRaster = raster::raster(grid,layer=1)
library(HydroMap)
head.grid.example3 <- krige.head(calibration.results = calib.results.example3, data=obs.data, use.cluster = T)
names(grid)
names(grid)
colnames
library(HydroMap)
head.grid.example3 <- krige.head(calibration.results = calib.results.example3, data=obs.data, use.cluster = T)
library(HydroMap)
head.grid.example3 <- krige.head(calibration.results = calib.results.example3, data=obs.data, use.cluster = T)
names(grid.asRaster
names(grid.asRaster)
grid.asRaster
grid.asRaster
grid.asRaster
head.asRaster
class(head)
class(grid
)
sp::gridded(grid) = TRUE
grid.asRaster = raster::raster(grid)
head.asRaster = raster::raster(head)
grid.asRaster
head.asRaster
if (extend.DEM) {
grid.asRaster = raster::crop(grid.asRaster, DEM.extent.input)
head.asRaster = raster::crop(head.asRaster, DEM.extent.input)
}
library(HydroMap)
head.grid.example3 <- krige.head(calibration.results = calib.results.example3, data=obs.data, use.cluster = T)
head.grid.example3$DTWT.cats =cut(head.grid.example3$DTWT,breaks=c(-Inf,0,2,5,10,25,50, Inf ),
labels=c('<0m','0-2m','2-5m','5-10m','10-25m','25-50m','>50m'),include.lowest=T)
sp::spplot(head.grid.example3,'DTWT.cats', scales = list(draw = TRUE))
